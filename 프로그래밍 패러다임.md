# 프로그래밍 패러다임

프로그래밍 패러다임은 프로그래밍할 때 관점을 제공해주고, 설계를 결정하도록 돕는 패러다임이다.  
예를 들어 프로그래밍을 함수적 호출 과정을 바로바고 설계한다면 `절차지향 프로그래밍`이 되고, 객체의 책임과 협력을 중심으로 설계한다면 `객체 지향 프로그래밍`이 된다.  
프로그래밍 패러다임에는 다음 3가지가 있다.  
- 절차지향 프로그래밍
- 객체지향 프로그래밍
- 함수지향 프로그래밍  


## 절차지향 프로그래밍
절차지향 프로그래밍은 프로시저 콜, 함수 호출 중심 프로그래밍을 말한다.
재사용 가능한 코드들은 별도의 함수로 분리하고 함수 간의 호출라 하고자 하는 일을 수행한다. 이런 프로세스는 주로 "함수"와 "조건문", "루프문"을 활용하여 코드를 구성한다.  

또한 절차지향 프로그래밍은 데이터를 중앙 집중식으로 관리한다. 즉 프로세스 로직과 데이터가 별도의 위치에 분리되어 있다. 프로세스 로직 부분에서는 어떤 데이터가 들어오는지 모르기 때문에 로직 내에 조건문 사용이 많은 경향이 있다.  

### 예시


```python

def read_input_file(file_path: str) -> str:
    if file_path.endswith(".txt"):
        reader = get_file_reader(file_type="txt")
        return reader.read(file_path)
    elif file_path.endswith(".csv"):
        reader = get_file_reader(file_type="csv")
        return reader.read(file_path)
    elif file_path.endswith(".xlsx"):
        reader = get_file_reader(file_type="xlsx")
        return reader.read(file_path)
    else:
        raise ValueError("파일 확장자는 txt, csv, xlsx 중 하나여야 합니다.")

def get_file_reader(file_type: str) -> Reader:
    if file_type == "txt":
   		...
    elif file_type == "csv":
        ...
    elif file_type == "xlsx":
        ...

def parse_input_data(data: str) -> List[str]:
    ...

def save_data(data: List[str]) -> None:
    ...

def main() -> None:
    data = read_input_file("input_file.txt")
    parsed_data = parse_input_data(data)
    save_data(parsed_data)
    
if __name__ == "__main__":
    main()

```
`main`함수는 하위 함수들의 호출로 이뤄져 있다. `main`함수만 보면 이 프로그램이 전체적으로 어떤 일을 하는지 쉽게 파악할 수 있다.  
절차지향 코드는 이렇게 전체 로직을 작은 함수 단위로 나누고 프로그래밍 메인 로직이 시작되는 곳부터 하위 로직이 실행되는 곳 까지 Top -> DOWN 식으로 구성된다.    
절차지향 프로그래밍은 한눈에 이해하기 쉽다.그러나 새로운 기능이 추가 될 수록 코드가 복잡해지고 동적으로 로직을 바꿔야하는 등의 기능 확장이 필요할 때 유지 보수가 어렵다.  

따라서 절차지향은 프로그램이 수행하는 알고리즘이 명확하고, 기능 확장 등이 자주 일어나지 않는 상황에서 사용하기에 좋다.    


## 객체 지향 프로그래밍  
`객체 지향 프로그래밍`은 객체라고 하는 단위에 책임을 명확히 하고 서로 협력하도록 프로그래밍을 하는 패러다임이다.   

모든 것을 객체로 나누어 생각하고, 필요할 때 객체들을 활용하고 서로 협력하여 일을 수행한다.  

절차지향과 다르게 객체는 데이터와 함수(메서드)를 함께 가지고 있다. 객체 내부의 데이터는 외부에 공개할 필요가 없거나 해서는 안 되는 데이터라면 모두 자신 내부에 숨겨 외부에서 알지 못하도록 한다.  

### 예시  

```python
class Processor:
    def __init__(self,
                 file_reader: FileReader,
                 data_parser: DataParser,
                 repository: Repository) -> None:
        self.file_reader = file_reader
        self.data_parser = data_parser
        self.repository = repository

    def execute(self, file_path: str) -> None:
        data = self.file_reader.read(file_path)
        parsed_data = self.data_parser.parse(data)
        self.repository.save(parsed_data)


class FileReader:
    def __init__(self) -> None:
        self.file_types = ["txt"]
        self.file_history = [] # 만약 절차 지향이라면 file_history 데이터를 중앙 집중으로 관리하게 됩니다. 

    def read(self, file_path: str) -> str:
        self._validate(file_path)
        ...

    def _validate(self, file_path: str) -> None:
        for file_type in self.file_types:
            if file_path.endswith(file_type):
                return
        raise ValueError("파일 확장자는 txt, csv, xlsx 중 하나여야 합니다.")

class DataParser:
    def parse(self, data: str) -> List[str]:
        ...

class Repository:
    def init(self, database_url: str, ...):
        ...
    
    def save(self, data: List[str]) -> None:
        ...

class Main:
    @staticmethod
    def run(self) -> None:
        processor = Processor(
            file_reader=FileReader(),
            data_parser=DataParser(),
            repository=Repository()
        )
        processor.execute("input_file.txt")


 if __name__ == "__main__":
    Main.run()
```  
위 코드는 `Processor`, `FileReader`등 여러 객체(클래스)로 이뤄진다. 그리고 각 객체는 각자 자신의 역할과 기능이 있다.   
프로그래밍은 전체적으로 객체와 객체 간의 메서드 호출로 이뤄진다. 그리고 각 객체는 자신의 기능을 수행하는데 필요한 데이터를 직접 가지고 있다. 
코드는 조금 더 복잡해졌지만, 객체 지향은 기능을 확잘할 때 효과적이다.    
예를들어 위 코드는 `txt`파일만 읽었는데, `csv`파일이나 `xlsx`파일도 읽어야 하는 상황이 주어졌다고 해보자. 그럼 다음 처럼 코드를 확장해볼 수 있다.  
```python
# FileReader는 이제 추상 클래스입니다.
class FileReader(ABC):
    def read(self, file_path: str) -> str:
        self._validate(file_path)
        data = self._open_file(file_path)
        return self._read(data)

    @abstractmethod
    def _read(self, data: str) -> str:
        pass

    # 공통으로 사용하는 메서드입니다.
    def _validate(self, file_path: str) -> None:
        if not file_path.endswith(self.file_type):
            raise ValueError(f"파일 확장자가 {self.file_type} 아닙니다.")

    @abstractmethod
    def _open_file(file_path: str) -> str:
        ...

# txt 파일을 읽는 책임을 가진 FileReader 파생 클래스입니다.
class TxtFileReader(FileReader):
    def file_type(self) -> str:
        return "txt"

    def _read(self, data: str) -> str:
        ...
    
    ...


# csv 파일을 읽는 책임을 가진 FileReader 파생 클래스입니다.
class CsvFileReader(FileReader):
    def file_type(self) -> str:
        return "csv"

    def _read(self, data: str) -> str:
        ...
    
    ...


# xlsx 파일을 읽는 책임을 가진 FileReader 파생 클래스입니다.
class XlsxFileReader(FileReader):
    def file_type(self) -> str:
        return "xlsx"

    def _read(self, data: str) -> str:
        ...

    ...

```

객체 지향을 지원하는 대부분의 프로그래밍 언어들은 `클래스`라는 문법을 제공한다. 객체의 강력한 기능인 `상속`을 이용하면 한 번 정의해놓은 메서드를 파생 클래스에서 재사용 가능하다.    
객체 지향의 가장 큰 특징은 같은 역할을 하는 객체를 쉽게 바꾸도록 설계할 수 있다는 것이다. 

### 장단점
객체 지향은 여러 명의 개발자들이 협력을 해야 하거나, 확장 가능하도록 코드를 설계해야 하는 경우에 적합하다.  

하지만 확장이 가능하고 유연한 만큼, 처음 코드를 보는 사람들은 어렵고 헷갈릴 수 있다.  
또한 실행 환경에서 입력에 따라 다양한 작업 흐름이 만들어지기 때문에 디버깅하기가 상대적으로 어렵다.    